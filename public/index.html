<!doctype html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MY1 Smart Trading Platform</title>
  <style>
    :root {
      color-scheme: light;
      --bg: radial-gradient(circle at 10% 20%, #0f172a, #1d4ed8 55%, #2563eb 100%);
      --surface: rgba(255, 255, 255, 0.92);
      --surface-strong: #ffffff;
      --text: #0f172a;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-dark: #1e40af;
      --accent-soft: rgba(37, 99, 235, 0.12);
      --success: #16a34a;
      --danger: #dc2626;
      --shadow: 0 32px 60px rgba(15, 23, 42, 0.28);
    }

    * { box-sizing: border-box; }

    body {
      font-family: "Inter", "Cairo", "Segoe UI", sans-serif;
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    a { color: inherit; text-decoration: none; }

    .site {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .site-header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(12px);
      background: rgba(15, 23, 42, 0.65);
      color: #fff;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .site-header .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px clamp(20px, 6vw, 48px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 18px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .logo {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 46px;
      height: 46px;
      border-radius: 16px;
      background: rgba(255,255,255,0.12);
      font-weight: 700;
      font-size: 1.1rem;
      letter-spacing: 0.08em;
    }

    .tagline {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .tagline strong {
      font-size: 1rem;
    }

    .tagline span {
      font-size: 0.85rem;
      color: rgba(255,255,255,0.7);
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .language-toggle {
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #fff;
      border-radius: 999px;
      padding: 8px 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .language-toggle:hover { background: rgba(255,255,255,0.18); }

    .ghost-link {
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      color: #fff;
      font-weight: 600;
      font-size: 0.95rem;
      transition: background 0.2s ease;
    }

    .ghost-link:hover { background: rgba(255,255,255,0.2); }

    .hero {
      padding: clamp(48px, 8vw, 100px) clamp(20px, 10vw, 140px);
      color: #fff;
      position: relative;
      overflow: hidden;
    }

    .hero::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(37, 99, 235, 0.45), transparent 52%),
                  radial-gradient(circle at bottom left, rgba(59, 130, 246, 0.42), transparent 55%);
      pointer-events: none;
    }

    .hero-content {
      position: relative;
      z-index: 1;
      display: grid;
      gap: clamp(32px, 5vw, 70px);
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      align-items: center;
    }

    .hero h1 {
      font-size: clamp(2.4rem, 5.6vw, 3.8rem);
      margin: 0 0 18px;
      line-height: 1.05;
    }

    .hero p {
      margin: 0;
      font-size: clamp(1rem, 2.4vw, 1.2rem);
      color: rgba(255,255,255,0.88);
      max-width: 540px;
    }

    .hero-actions {
      margin-top: 28px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .btn {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 12px 22px;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn.primary {
      background: #fff;
      color: var(--accent);
      box-shadow: 0 20px 50px rgba(15, 23, 42, 0.35);
    }

    .btn.primary:hover { transform: translateY(-2px); }

    .btn.secondary {
      background: rgba(255,255,255,0.14);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.25);
    }

    .btn.secondary:hover { background: rgba(255,255,255,0.25); }

    .btn-text {
      border: none;
      background: transparent;
      color: var(--accent);
      font-weight: 600;
      cursor: pointer;
      padding: 0;
      font-size: 0.9rem;
    }

    .btn-text.danger { color: var(--danger); }

    .features {
      position: relative;
      z-index: 1;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
    }

    .feature-card {
      background: rgba(15, 23, 42, 0.55);
      color: #fff;
      padding: 20px 22px;
      border-radius: 20px;
      backdrop-filter: blur(14px);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 20px 50px rgba(15, 23, 42, 0.35);
    }

    .feature-card h3 { margin: 0 0 12px; font-size: 1.15rem; }
    .feature-card p { margin: 0; font-size: 0.95rem; color: rgba(255,255,255,0.82); }

    .auth-section {
      margin-top: -90px;
      padding: 0 clamp(20px, 7vw, 140px) clamp(80px, 9vw, 140px);
      display: flex;
      justify-content: center;
    }

    .auth-card {
      background: var(--surface);
      border-radius: 26px;
      box-shadow: var(--shadow);
      max-width: 1000px;
      width: 100%;
      padding: clamp(26px, 4vw, 52px);
      display: grid;
      gap: 26px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    .auth-copy h2 { margin: 0 0 16px; font-size: 1.7rem; }
    .auth-copy p { margin: 0; color: var(--muted); line-height: 1.6; }

    .auth-panel {
      background: var(--surface-strong);
      border-radius: 22px;
      padding: 24px 26px;
      border: 1px solid rgba(15, 23, 42, 0.08);
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .auth-tabs {
      display: inline-flex;
      background: rgba(15, 23, 42, 0.05);
      border-radius: 14px;
      padding: 4px;
      margin-bottom: 12px;
    }

    .auth-tabs button {
      border: none;
      background: transparent;
      padding: 10px 18px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      color: var(--muted);
      transition: background 0.2s ease, color 0.2s ease;
    }

    .auth-tabs button.is-active {
      background: var(--surface);
      color: var(--accent);
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.18);
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    label {
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 6px;
      display: block;
    }

    input, textarea {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(15, 23, 42, 0.12);
      background: rgba(241, 245, 249, 0.7);
      font-size: 0.95rem;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    input:focus, textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
      background: #fff;
    }

    .muted { color: var(--muted); }
    .small { font-size: 0.85rem; }

    .hidden { display: none !important; }

    /* Dashboard */
    #dashboard {
      padding: clamp(40px, 6vw, 72px) clamp(20px, 8vw, 120px);
      background: #f5f6fb;
      min-height: 100vh;
    }

    .dashboard-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: flex-start;
      gap: 24px;
      margin-bottom: 28px;
    }

    .dashboard-header h1 {
      margin: 0 0 8px;
      font-size: clamp(1.8rem, 4vw, 2.4rem);
    }

    .user-meta {
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      padding: 6px 14px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.85rem;
      background: rgba(37, 99, 235, 0.12);
      color: var(--accent);
    }

    .pill.success { background: rgba(22, 163, 74, 0.16); color: var(--success); }
    .pill.danger { background: rgba(220, 38, 38, 0.12); color: var(--danger); }

    .dashboard-grid {
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      margin-bottom: 32px;
    }

    .card {
      background: #fff;
      border-radius: 22px;
      padding: 26px;
      box-shadow: 0 24px 55px rgba(15, 23, 42, 0.12);
      border: 1px solid rgba(148, 163, 184, 0.18);
    }

    .card h2 { margin: 0 0 12px; font-size: 1.2rem; }
    .card p { margin: 0 0 12px; color: var(--muted); }

    .status {
      min-height: 24px;
      margin-bottom: 20px;
      font-weight: 600;
      transition: opacity 0.25s ease;
    }

    .status.success { color: var(--success); }
    .status.error { color: var(--danger); }
    .status.info { color: var(--accent); }

    .form-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 16px;
    }

    .actions { display: flex; gap: 12px; flex-wrap: wrap; }

    .btn.ghost {
      background: rgba(15, 23, 42, 0.05);
      color: var(--text);
    }

    .btn.danger {
      background: rgba(220, 38, 38, 0.12);
      color: var(--danger);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    .btn[data-loading="true"]::after {
      content: "";
      width: 16px;
      height: 16px;
      border: 3px solid rgba(255,255,255,0.45);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.75s linear infinite;
    }

    .btn.primary[data-loading="true"]::after {
      border-color: rgba(37, 99, 235, 0.35);
      border-top-color: var(--accent);
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .pricing {
      padding: clamp(48px, 8vw, 96px) clamp(20px, 8vw, 120px);
      background: #f7f8fe;
    }

    .pricing-inner {
      max-width: 1100px;
      margin: 0 auto;
      display: grid;
      gap: 28px;
      text-align: center;
    }

    .pricing-grid {
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .pricing-grid.compact {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .plan-card {
      background: var(--surface-strong);
      border-radius: 24px;
      padding: 28px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: 0 24px 55px rgba(15, 23, 42, 0.08);
      display: flex;
      flex-direction: column;
      gap: 18px;
      text-align: left;
    }

    .pricing-grid.compact .plan-card {
      box-shadow: none;
      border: 1px solid rgba(148, 163, 184, 0.24);
      padding: 22px;
    }

    .plan-card.current {
      border-color: var(--accent);
      box-shadow: 0 32px 60px rgba(37, 99, 235, 0.18);
    }

    .plan-card.pending {
      border-color: rgba(234, 179, 8, 0.6);
      box-shadow: 0 28px 60px rgba(234, 179, 8, 0.18);
    }

    .plan-card.pending .plan-badge {
      background: rgba(234, 179, 8, 0.16);
      color: #b45309;
    }

    .plan-card h3 {
      margin: 0;
      font-size: 1.25rem;
    }

    .plan-price {
      font-size: 2.2rem;
      font-weight: 700;
      line-height: 1;
    }

    .plan-price span {
      font-size: 0.85rem;
      color: var(--muted);
      margin-left: 6px;
    }

    .plan-feature-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 10px;
    }

    .plan-feature-list li {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.95rem;
    }

    .plan-feature-list li::before {
      content: "•";
      color: var(--accent);
      font-weight: 700;
    }

    .plan-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .plan-actions .btn {
      flex: 1 1 180px;
    }

    .plan-badge {
      display: inline-flex;
      align-items: center;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      background: var(--accent-soft);
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .plan-warning {
      display: none;
      margin: 12px 0;
      padding: 10px 14px;
      border-radius: 12px;
      background: rgba(220, 38, 38, 0.12);
      color: var(--danger);
      font-size: 0.9rem;
    }

    .plan-warning.visible {
      display: block;
    }

    .plan-warning.info {
      background: rgba(37, 99, 235, 0.12);
      color: var(--accent);
    }

    .subscription-card {
      position: relative;
    }

    .card.full {
      grid-column: 1 / -1;
    }

    .subscription-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 12px;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      padding: 6px 14px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.85rem;
      background: rgba(37, 99, 235, 0.12);
      color: var(--accent);
    }

    .status-pill.pending {
      background: rgba(251, 191, 36, 0.18);
      color: #b45309;
    }

    .status-pill.expired {
      background: rgba(220, 38, 38, 0.12);
      color: var(--danger);
    }

    .subscription-body {
      display: grid;
      gap: 12px;
      margin-bottom: 12px;
    }

    .subscription-summary {
      display: grid;
      gap: 6px;
    }

    .subscription-summary strong {
      font-size: 1rem;
    }

    .subscription-meta {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .subscription-features {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .subscription-features .feature {
      padding: 6px 12px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.85rem;
      background: rgba(37, 99, 235, 0.12);
      color: var(--accent);
    }

    .subscription-features .feature.disabled {
      background: rgba(220, 38, 38, 0.12);
      color: var(--danger);
    }

    .subscription-actions {
      display: grid;
      gap: 12px;
      margin-bottom: 16px;
    }

    .subscription-plans {
      margin-top: 8px;
    }

    .subscription-plans h3,
    .subscription-history h3 {
      margin: 0 0 12px;
      font-size: 1rem;
    }

    .subscription-history {
      margin-top: 20px;
    }

    .history-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 10px;
    }

    .history-list li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.16);
      background: #f9fafc;
      font-size: 0.9rem;
    }

    .history-list li .label {
      font-weight: 600;
    }

    .history-list li .meta {
      color: var(--muted);
      font-size: 0.8rem;
    }

    .provider-label {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: rgba(15, 23, 42, 0.25);
      transition: background 0.2s ease;
      border-radius: 999px;
    }

    .slider::before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: #fff;
      transition: transform 0.2s ease;
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.25);
    }

    .switch input:checked + .slider {
      background: linear-gradient(135deg, #22c55e, #16a34a);
    }

    .switch input:checked + .slider::before {
      transform: translateX(20px);
    }

    .table-card { margin-bottom: 28px; }
    .table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 16px;
    }

    .table-wrapper { overflow-x: auto; }
    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 680px;
    }

    th, td {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      text-align: left;
      font-size: 0.92rem;
    }

    thead th {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--muted);
      background: rgba(15, 23, 42, 0.03);
    }

    tbody tr:last-child td { border-bottom: none; }
    tbody tr.is-paused { opacity: 0.65; }

    .symbol { font-weight: 700; letter-spacing: 0.02em; font-size: 1rem; }
    details.ai-details summary {
      cursor: pointer;
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--accent);
    }

    details.ai-details {
      margin-top: 6px;
    }

    .ai-summary {
      background: rgba(15, 23, 42, 0.04);
      padding: 10px 12px;
      border-radius: 10px;
      margin-top: 6px;
      font-size: 0.85rem;
      color: var(--text);
      white-space: pre-wrap;
    }

    .completed-trades-note {
      display: none;
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 12px;
    }

    .completed-trades-note.visible {
      display: block;
    }

    .completed-trades-card .table-header {
      align-items: flex-start;
      gap: 12px;
    }

    .completed-trades-wrapper {
      margin-top: 16px;
      background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(241,245,249,0.85));
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 22px;
      padding: 12px;
      box-shadow: 0 24px 55px rgba(15, 23, 42, 0.12);
      overflow: hidden;
    }

    .completed-trades-table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0 12px;
      min-width: 640px;
    }

    .completed-trades-table thead th {
      background: transparent;
      color: rgba(15, 23, 42, 0.6);
      font-weight: 600;
      padding-bottom: 0;
    }

    .completed-trades-table tbody tr {
      background: rgba(255, 255, 255, 0.96);
      border-radius: 18px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.12);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .completed-trades-table tbody tr:hover {
      transform: translateY(-2px);
      box-shadow: 0 28px 55px rgba(15, 23, 42, 0.18);
    }

    .completed-trades-table tbody tr td {
      border-bottom: none;
      padding: 18px 20px;
      vertical-align: top;
    }

    .completed-trades-table tbody tr td:first-child {
      border-top-left-radius: 18px;
      border-bottom-left-radius: 18px;
    }

    .completed-trades-table tbody tr td:last-child {
      border-top-right-radius: 18px;
      border-bottom-right-radius: 18px;
    }

    .completed-trades-table .pair {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .completed-trades-table .pair-symbol {
      font-weight: 700;
      font-size: 1.05rem;
      letter-spacing: 0.04em;
    }

    .completed-trades-table .pair-base {
      font-size: 0.78rem;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.08em;
    }

    .completed-trades-table .status-pill {
      display: inline-flex;
      align-items: center;
      width: max-content;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.12);
      color: var(--accent);
      font-size: 0.72rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      margin-top: 4px;
    }

    .completed-trades-table .metric-value {
      font-weight: 600;
      font-size: 1rem;
    }

    .completed-trades-table .metric-sub {
      font-size: 0.82rem;
      color: var(--muted);
      margin-top: 4px;
    }

    .completed-trades-table .profit-amount {
      font-size: 1.1rem;
      font-weight: 700;
    }

    .completed-trades-table .profit-amount.positive {
      color: var(--success);
    }

    .completed-trades-table .profit-amount.negative {
      color: var(--danger);
    }

    .completed-trades-table .profit-amount.neutral {
      color: var(--text);
    }

    .completed-trades-table .profit-return {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.12);
      color: var(--accent);
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .completed-trades-table .profit-amount.negative + .profit-return {
      background: rgba(220, 38, 38, 0.12);
      color: var(--danger);
    }

    .completed-trades-table .profit-amount.neutral + .profit-return {
      background: rgba(148, 163, 184, 0.18);
      color: var(--muted);
    }

    .completed-trades-table .cycle {
      display: grid;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .completed-trades-table .cycle span {
      display: inline-flex;
      gap: 6px;
      align-items: baseline;
    }

    .completed-trades-table .cycle strong {
      color: var(--text);
      font-weight: 600;
    }

    .empty-state {
      padding: 28px 22px;
      border-radius: 18px;
      border: 1px dashed rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.03);
      text-align: center;
      font-weight: 500;
      color: var(--muted);
    }

    .rule-error {
      margin-top: 8px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(220, 38, 38, 0.08);
      color: var(--danger);
      font-size: 0.8rem;
      line-height: 1.4;
    }

    tr.empty-row td {
      text-align: center;
      padding: 36px 16px;
      color: var(--muted);
      font-weight: 500;
    }

    @media (max-width: 768px) {
      .site-header .container { flex-direction: column; align-items: stretch; }
      .brand { justify-content: space-between; }
      .header-actions { justify-content: space-between; }
      .auth-card { padding: 24px; }
      table { min-width: 100%; }
      thead { display: none; }
      tbody tr { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; padding: 12px 0; }
      tbody td { border-bottom: none; padding: 0; font-size: 0.9rem; }
      tbody td::before {
        content: attr(data-label);
        display: block;
        font-weight: 600;
        color: var(--muted);
        margin-bottom: 4px;
      }
      .completed-trades-wrapper {
        padding: 0;
        border-radius: 18px;
        box-shadow: none;
      }
      .completed-trades-table {
        border-spacing: 0;
      }
      .completed-trades-table tbody tr {
        grid-template-columns: 1fr;
        padding: 16px;
        box-shadow: none;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.96);
      }
      .completed-trades-table tbody tr td {
        padding: 0;
      }
      .completed-trades-table .profit-return {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <div class="site">
    <header class="site-header">
      <div class="container">
        <div class="brand">
          <span class="logo">MY1</span>
          <div class="tagline">
            <strong data-i18n="header.taglineTitle">Smart crypto autopilot</strong>
            <span data-i18n="header.taglineSubtitle">Designed for modern spot traders.</span>
          </div>
        </div>
        <div class="header-actions">
          <button id="languageToggle" class="language-toggle" type="button">عربي</button>
          <a class="ghost-link" data-scroll-to-auth href="#authSection" data-i18n="header.cta">Explore dashboard</a>
        </div>
      </div>
    </header>

    <section class="hero" id="landing">
      <div class="hero-content">
        <div>
          <h1 data-i18n="hero.title">Trade smarter with AI-assisted automation</h1>
          <p data-i18n="hero.subtitle">MY1 monitors the market in real time, suggests AI-powered strategies, and executes your spot rules with transparent controls.</p>
          <div class="hero-actions">
            <button class="btn primary" data-scroll-to-auth type="button" data-i18n="hero.primaryCta">Start now</button>
            <button class="btn secondary" type="button" data-scroll-to-auth data-i18n="hero.secondaryCta">See how it works</button>
          </div>
        </div>
        <div class="features">
          <article class="feature-card">
            <h3 data-i18n="features.automationTitle">Personal rule engine</h3>
            <p data-i18n="features.automationCopy">Define dip buying and take-profit logic with full transparency. Rules stay under your account control.</p>
          </article>
          <article class="feature-card">
            <h3 data-i18n="features.securityTitle">Secure key management</h3>
            <p data-i18n="features.securityCopy">Connect Binance spot keys with encryption. You are always able to rotate or disconnect in one click.</p>
          </article>
          <article class="feature-card">
            <h3 data-i18n="features.aiTitle">AI market insights</h3>
            <p data-i18n="features.aiCopy">Leverage live market research prompts to craft strategies backed by up-to-date data.</p>
          </article>
        </div>
      </div>
    </section>

    <section class="pricing" id="pricingSection">
      <div class="pricing-inner">
        <h2 data-i18n="pricing.title">Plans built for every trader</h2>
        <p class="muted" data-i18n="pricing.subtitle">Unlock manual or AI-powered automation by choosing the package that matches your strategy.</p>
        <div class="pricing-grid" id="pricingGrid"></div>
      </div>
    </section>

    <section class="auth-section" id="authSection">
      <div class="auth-card">
        <div class="auth-copy">
          <h2 data-i18n="auth.title">Your personal trading cockpit</h2>
          <p data-i18n="auth.description">Track AI-generated ideas, manage manual rules, and sync Binance activity from a single secure interface.</p>
        </div>
        <div class="auth-panel">
          <div class="auth-tabs">
            <button type="button" class="is-active" data-auth-tab="login" data-i18n="auth.loginTab">Sign in</button>
            <button type="button" data-auth-tab="register" data-i18n="auth.registerTab">Create account</button>
          </div>
          <form id="loginForm" data-auth-panel="login">
            <div>
              <label for="loginEmail" data-i18n="auth.emailLabel">Email</label>
              <input id="loginEmail" type="email" autocomplete="email" required data-i18n-placeholder="auth.emailPlaceholder">
            </div>
            <div>
              <label for="loginPassword" data-i18n="auth.passwordLabel">Password</label>
              <input id="loginPassword" type="password" autocomplete="current-password" required data-i18n-placeholder="auth.passwordPlaceholder">
            </div>
            <button class="btn primary" type="submit" data-i18n="auth.loginCta">Sign in</button>
          </form>
          <form id="registerForm" data-auth-panel="register" class="hidden">
            <div>
              <label for="registerName" data-i18n="auth.nameLabel">Full name</label>
              <input id="registerName" required data-i18n-placeholder="auth.namePlaceholder">
            </div>
            <div>
              <label for="registerEmail" data-i18n="auth.emailLabel">Email</label>
              <input id="registerEmail" type="email" autocomplete="email" required data-i18n-placeholder="auth.emailPlaceholder">
            </div>
            <div>
              <label for="registerPassword" data-i18n="auth.passwordLabel">Password</label>
              <input id="registerPassword" type="password" autocomplete="new-password" required data-i18n-placeholder="auth.passwordPlaceholder">
            </div>
            <button class="btn primary" type="submit" data-i18n="auth.registerCta">Create account</button>
          </form>
        </div>
      </div>
    </section>

    <main id="dashboard" class="hidden">
      <div class="dashboard-header">
        <div>
          <h1 data-i18n="dashboard.title">MY1 control center</h1>
          <p class="muted" data-i18n="dashboard.subtitle">Manage AI ideas, monitor open orders, and keep your Binance link under supervision.</p>
        </div>
        <div class="user-meta">
          <span class="pill" id="welcomeName" data-i18n="dashboard.welcome">Welcome</span>
          <button class="btn ghost" id="logoutBtn" type="button" data-i18n="dashboard.logout">Sign out</button>
        </div>
      </div>

      <div id="status" class="status" role="status" aria-live="polite"></div>

      <section class="dashboard-grid">
        <article class="card subscription-card full" id="subscriptionCard">
          <div class="subscription-header">
            <h2 data-i18n="subscription.title">Your plan</h2>
            <span class="status-pill" id="subscriptionStatus"></span>
          </div>
          <div class="subscription-body">
            <div class="subscription-summary" id="subscriptionSummary"></div>
            <div class="subscription-features" id="subscriptionFeatures"></div>
            <div class="plan-warning" id="subscriptionWarning"></div>
          </div>
          <div class="subscription-actions" id="subscriptionActions"></div>
          <div class="subscription-plans">
            <h3 data-i18n="subscription.availablePlans">Available plans</h3>
            <div class="pricing-grid compact" id="dashboardPlans"></div>
          </div>
          <div class="subscription-history">
            <h3 data-i18n="subscription.historyTitle">Recent payments</h3>
            <ul class="history-list" id="subscriptionHistory"></ul>
          </div>
        </article>
        <article class="card">
          <h2 data-i18n="api.title">Connect Binance keys</h2>
          <p data-i18n="api.description">Add your spot API credentials to activate the engine. Keys remain encrypted and you can revoke them any time.</p>
          <div>
            <span data-i18n="api.statusLabel">Status:</span> <span id="apiKeysStatus" class="pill danger" data-i18n="api.disconnected">Disconnected</span>
          </div>
          <form id="apiKeysForm">
            <div>
              <label for="apiKey" data-i18n="api.keyLabel">API key</label>
              <input id="apiKey" autocomplete="off" required placeholder="XXXXXXXX">
            </div>
            <div>
              <label for="apiSecret" data-i18n="api.secretLabel">API secret</label>
              <input id="apiSecret" autocomplete="off" required placeholder="XXXXXXXX">
            </div>
            <div class="actions">
              <button class="btn primary" type="submit" data-i18n="api.save">Save keys</button>
              <button class="btn ghost" type="button" id="removeKeys" data-i18n="api.remove">Disconnect</button>
            </div>
            <p class="muted small" data-i18n="api.helper">Use spot trading keys with read and trade permissions only.</p>
          </form>
        </article>

        <article class="card">
          <h2 data-i18n="manual.title">Manual rule</h2>
          <p data-i18n="manual.description">Create a dip buying strategy with your preferred take-profit target.</p>
          <div class="plan-warning" id="manualRestriction"></div>
          <form id="manualForm">
            <div class="form-row">
              <div>
                <label for="symbol" data-i18n="manual.symbolLabel">Pair</label>
                <input id="symbol" required data-i18n-placeholder="manual.symbolPlaceholder">
              </div>
              <div>
                <label for="dip" data-i18n="manual.dipLabel">Buy the dip %</label>
                <input id="dip" type="number" step="0.01" min="0" required data-i18n-placeholder="manual.dipPlaceholder">
              </div>
            </div>
            <div class="form-row">
              <div>
                <label for="tp" data-i18n="manual.tpLabel">Take profit %</label>
                <input id="tp" type="number" step="0.01" min="0" required data-i18n-placeholder="manual.tpPlaceholder">
              </div>
              <div>
                <label for="budget" data-i18n="manual.budgetLabel">Trade budget (USDT)</label>
                <input id="budget" type="number" step="0.01" min="0" required data-i18n-placeholder="manual.budgetPlaceholder">
              </div>
            </div>
            <div class="actions">
              <button class="btn primary" type="submit" data-i18n="manual.add">Add rule</button>
              <button class="btn ghost" type="button" id="syncRules" data-i18n="manual.sync">Sync with engine</button>
            </div>
          </form>
        </article>

        <article class="card">
          <h2 data-i18n="ai.title">AI-powered rule</h2>
          <p data-i18n="ai.description">Request a market-ready spot strategy backed by real-time research.</p>
          <div class="plan-warning" id="aiRestriction"></div>
          <form id="aiForm">
            <div>
              <label for="aiBudget" data-i18n="ai.budgetLabel">AI budget (USDT)</label>
              <input id="aiBudget" type="number" min="10" value="100" required>
            </div>
            <div>
              <label for="aiModel" data-i18n="ai.modelLabel">Model</label>
              <input id="aiModel" value="gpt-4o-mini" disabled>
            </div>
            <button class="btn primary" id="aiGenerate" type="submit" data-i18n="ai.generate">Generate with AI</button>
            <p class="muted small" data-i18n="ai.helper">The assistant researches live data before returning a ready-to-use rule.</p>
          </form>
        </article>
      </section>
      <section class="card table-card">
        <div class="table-header">
          <h2 data-i18n="manual.tableTitle">Manual rules</h2>
          <span class="pill" id="manualCount">0</span>
        </div>
        <div class="table-wrapper">
          <table class="data-table" id="manualRulesTable">
            <thead>
              <tr>
                <th data-i18n="manual.table.rule">Rule</th>
                <th data-i18n="manual.table.targets">Targets</th>
                <th data-i18n="manual.table.budget">Budget</th>
                <th data-i18n="manual.table.status">Status</th>
                <th data-i18n="manual.table.actions">Actions</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <section class="card table-card">
        <div class="table-header">
          <h2 data-i18n="ai.tableTitle">AI rules</h2>
          <span class="pill" id="aiCount">0</span>
        </div>
        <div class="table-wrapper">
          <table class="data-table" id="aiRulesTable">
            <thead>
              <tr>
                <th data-i18n="ai.table.rule">Rule</th>
                <th data-i18n="ai.table.entry">Entry price</th>
                <th data-i18n="ai.table.exit">Take-profit</th>
                <th data-i18n="ai.table.budget">Budget</th>
                <th data-i18n="ai.table.status">Status</th>
                <th data-i18n="ai.table.actions">Actions</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <section class="card table-card">
        <div class="table-header">
          <h2 data-i18n="orders.title">Open orders</h2>
          <div class="actions">
            <button class="btn ghost" id="refreshOrders" type="button" data-i18n="orders.refresh">Refresh</button>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="data-table" id="ordersTable">
            <thead>
              <tr>
                <th data-i18n="orders.table.symbol">Pair</th>
                <th data-i18n="orders.table.side">Side</th>
                <th data-i18n="orders.table.price">Price</th>
                <th data-i18n="orders.table.qty">Quantity</th>
                <th data-i18n="orders.table.type">Type</th>
                <th data-i18n="orders.table.status">Status</th>
                <th data-i18n="orders.table.updated">Last update</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>
      <section class="card table-card completed-trades-card">
        <div class="table-header">
          <div>
            <h2 data-i18n="completed.title">Completed trades</h2>
            <p class="muted small" data-i18n="completed.subtitle">Latest buy &amp; sell cycles with realised profit.</p>
          </div>
          <div class="actions">
            <button class="btn ghost" id="refreshCompletedTrades" type="button" data-i18n="completed.refresh">Refresh</button>
          </div>
        </div>
        <p class="completed-trades-note small" id="completedTradesNotice"></p>
        <div class="table-wrapper completed-trades-wrapper">
          <table class="data-table completed-trades-table" id="completedTradesTable">
            <thead>
              <tr>
                <th data-i18n="completed.table.pair">Pair</th>
                <th data-i18n="completed.table.quantity">Quantity</th>
                <th data-i18n="completed.table.avgBuy">Avg buy</th>
                <th data-i18n="completed.table.avgSell">Avg sell</th>
                <th data-i18n="completed.table.profit">Profit</th>
                <th data-i18n="completed.table.cycle">Cycle</th>
              </tr>
            </thead>
            <tbody id="completedTradesList"></tbody>
          </table>
        </div>
      </section>
    </main>
  </div>

  <script>
  (function(){
    const translations = {
      en: {
        meta: { title: "MY1 Smart Trading Platform" },
        header: {
          taglineTitle: "Smart crypto autopilot",
          taglineSubtitle: "Designed for modern spot traders.",
          cta: "Explore dashboard"
        },
        hero: {
          title: "Trade smarter with AI-assisted automation",
          subtitle: "MY1 monitors the market in real time, suggests AI-powered strategies, and executes your spot rules with transparent controls.",
          primaryCta: "Start now",
          secondaryCta: "See how it works"
        },
        features: {
          automationTitle: "Personal rule engine",
          automationCopy: "Define dip buying and take-profit logic with full transparency. Rules stay under your account control.",
          securityTitle: "Secure key management",
          securityCopy: "Connect Binance spot keys with encryption. You are always able to rotate or disconnect in one click.",
          aiTitle: "AI market insights",
          aiCopy: "Leverage live market research prompts to craft strategies backed by up-to-date data."
        },
        pricing: {
          title: "Plans built for every trader",
          subtitle: "Unlock manual or AI-powered automation by choosing the package that matches your strategy.",
          manualFeature: "Manual rules: {{count}} active",
          aiFeature: "AI rules: {{count}} active",
          aiDisabled: "AI rules not included",
          manualOnly: "Manual automation included",
          duration: "{{days}} day subscription",
          price: "${{price}}"
        },
        auth: {
          title: "Your personal trading cockpit",
          description: "Track AI-generated ideas, manage manual rules, and sync Binance activity from a single secure interface.",
          loginTab: "Sign in",
          registerTab: "Create account",
          emailLabel: "Email",
          emailPlaceholder: "name@example.com",
          passwordLabel: "Password",
          passwordPlaceholder: "Enter password",
          nameLabel: "Full name",
          namePlaceholder: "How should we greet you?",
          loginCta: "Sign in",
          registerCta: "Create account"
        },
        dashboard: {
          title: "MY1 control center",
          subtitle: "Manage AI ideas, monitor open orders, and keep your Binance link under supervision.",
          welcome: "Welcome",
          logout: "Sign out"
        },
        api: {
          title: "Connect Binance keys",
          description: "Add your spot API credentials to activate the engine. Keys remain encrypted and you can revoke them any time.",
          statusLabel: "Status:",
          connected: "Connected",
          disconnected: "Disconnected",
          keyLabel: "API key",
          secretLabel: "API secret",
          save: "Save keys",
          remove: "Disconnect",
          helper: "Use spot trading keys with read and trade permissions only."
        },
        manual: {
          title: "Manual rule",
          description: "Create a dip buying strategy with your preferred take-profit target.",
          symbolLabel: "Pair",
          symbolPlaceholder: "Example: SOLUSDT",
          dipLabel: "Buy the dip %",
          dipPlaceholder: "2",
          tpLabel: "Take profit %",
          tpPlaceholder: "2",
          budgetLabel: "Trade budget (USDT)",
          budgetPlaceholder: "50",
          add: "Add rule",
          sync: "Sync with engine",
          tableTitle: "Manual rules",
          table: {
            rule: "Rule",
            targets: "Targets",
            budget: "Budget",
            status: "Status",
            actions: "Actions"
          }
        },
        ai: {
          title: "AI-powered rule",
          description: "Request a market-ready spot strategy backed by real-time research.",
          budgetLabel: "AI budget (USDT)",
          modelLabel: "Model",
          generate: "Generate with AI",
          helper: "The assistant researches live data before returning a ready-to-use rule.",
          tableTitle: "AI rules",
          table: {
            rule: "Rule",
            entry: "Entry price",
            exit: "Take-profit",
            budget: "Budget",
            status: "Status",
            actions: "Actions"
          }
        },
        orders: {
          title: "Open orders",
          refresh: "Refresh",
          table: {
            symbol: "Pair",
            side: "Side",
            price: "Price",
            qty: "Quantity",
            type: "Type",
            status: "Status",
            updated: "Last update"
          },
          empty: "No open orders right now."
        },
        completed: {
          title: "Completed trades",
          subtitle: "Latest buy & sell cycles with realised profit.",
          refresh: "Refresh",
          status: "Completed",
          closed: "Closed",
          opened: "Opened",
          duration: "Duration",
          instant: "Instant",
          empty: "No completed trades yet.",
          table: {
            pair: "Pair",
            quantity: "Quantity",
            avgBuy: "Avg buy",
            avgSell: "Avg sell",
            profit: "Profit",
            cycle: "Cycle"
          },
          labels: {
            quantity: "Quantity",
            avgBuy: "Avg buy",
            avgSell: "Avg sell",
            profit: "Profit",
            return: "Return"
          }
        },
        manualRules: {
          buyOnDipLabel: "Buy on dip:",
          takeProfitLabel: "Take profit:",
          empty: "No manual rules yet."
        },
        aiRules: {
          summaryToggle: "View AI summary",
          empty: "No AI rules yet."
        },
        common: {
          delete: "Delete",
          confirmDelete: "Delete this rule?",
          enabled: "Enabled",
          disabled: "Disabled"
        },
        status: {
          loginSuccess: "Signed in successfully.",
          registerSuccess: "Account created successfully.",
          keysSaved: "API keys saved.",
          keysRemoved: "Connection removed.",
          manualAdded: "Manual rule added.",
          manualSynced: "Rules synced with engine.",
          aiGenerated: "AI rule generated successfully.",
          ordersRefreshed: "Open orders refreshed.",
          completedRefreshed: "Completed trades updated.",
          ruleActivated: "Rule enabled.",
          rulePaused: "Rule paused.",
          ruleDeleted: "Rule deleted.",
          aiBudgetInvalid: "Enter a valid AI budget.",
          manualLocked: "Manual rules are disabled for your current plan.",
          aiLocked: "AI rules are disabled for your current plan.",
          manualLimit: "Your plan allows up to {{count}} manual rules.",
          aiLimit: "Your plan allows up to {{count}} AI rules.",
          checkoutStarted: "Redirecting you to complete the payment...",
          checkoutError: "Unable to start the checkout. Please try again."
        },
        subscription: {
          title: "Your plan",
          statusActive: "Active",
          statusExpired: "Expired",
          statusPending: "Awaiting payment",
          statusNone: "No active subscription",
          noPlan: "No active subscription. Pick a plan to unlock automation.",
          currentPlan: "Current plan: {{name}}",
          expires: "Expires on {{date}}",
          daysLeft: "{{count}} days remaining",
          daysLeftOne: "1 day remaining",
          manualFeature: "Manual rules: {{used}} / {{limit}} active",
          manualUnlimited: "Manual rules enabled",
          aiFeature: "AI rules: {{used}} / {{limit}} active",
          aiUnlimited: "AI rules enabled",
          manualDisabled: "Manual rules are disabled for your current plan.",
          aiDisabled: "AI rules are disabled for your current plan.",
          availablePlans: "Available plans",
          chooseProvider: "Checkout with",
          payWithStripe: "Pay with card (Stripe)",
          payWithCryptomus: "Pay with crypto (Cryptomus)",
          loginRequired: "Sign in to subscribe to a plan.",
          renewing: "Processing payment confirmation...",
          historyTitle: "Recent payments",
          historyEmpty: "No subscription history yet.",
          pendingNotice: "Awaiting payment confirmation for {{name}}.",
          providerStripe: "Stripe",
          providerCryptomus: "Cryptomus",
          noPlans: "Plans will be available soon."
        },
        ruleErrors: {
          symbolNotWhitelisted: "Binance rejected {{symbol}} because it isn't whitelisted for your API key. Enable the pair in your Binance API restrictions and try again."
        }
      },
      ar: {
        meta: { title: "منصة MY1 للتداول الذكي" },
        header: {
          taglineTitle: "طيار آلي ذكي للعملات الرقمية",
          taglineSubtitle: "مصمم لمتداولي السبوت العصريين.",
          cta: "استكشف اللوحة"
        },
        hero: {
          title: "تداول بذكاء مع أتمتة مدعومة بالذكاء الاصطناعي",
          subtitle: "تراقب MY1 السوق لحظيًا، وتقترح استراتيجيات مدعومة بالذكاء الاصطناعي، وتنفذ قواعدك بوضوح كامل.",
          primaryCta: "ابدأ الآن",
          secondaryCta: "تعرّف على آلية العمل"
        },
        features: {
          automationTitle: "محرك قواعد شخصي",
          automationCopy: "كوِّن قواعد شراء عند الانخفاض وجني ربح مع تحكم كامل. تبقى القواعد تحت إدارة حسابك دائمًا.",
          securityTitle: "إدارة مفاتيح آمنة",
          securityCopy: "اربط مفاتيح Binance Spot بتشفير كامل مع إمكانية الفصل أو التدوير بضغطة زر.",
          aiTitle: "رؤى سوقية بالذكاء الاصطناعي",
          aiCopy: "استفد من برومبتات بحث مباشرة لصياغة استراتيجيات مبنية على بيانات محدثة."
        },
        pricing: {
          title: "خطط تناسب كل متداول",
          subtitle: "اختر الباقة التي تناسب استراتيجيتك لتفعيل القواعد اليدوية أو الذكاء الاصطناعي.",
          manualFeature: "القواعد اليدوية: {{count}} مفعلة",
          aiFeature: "قواعد الذكاء الاصطناعي: {{count}} مفعلة",
          aiDisabled: "قواعد الذكاء الاصطناعي غير متضمنة",
          manualOnly: "تشمل القواعد اليدوية",
          duration: "اشتراك لمدة {{days}} يوم",
          price: "{{price}} دولار"
        },
        auth: {
          title: "قمرة القيادة الخاصة بك",
          description: "تابع أفكار الذكاء الاصطناعي، أدر القواعد اليدوية، وراقب نشاط Binance من واجهة آمنة واحدة.",
          loginTab: "تسجيل الدخول",
          registerTab: "إنشاء حساب",
          emailLabel: "البريد الإلكتروني",
          emailPlaceholder: "name@example.com",
          passwordLabel: "كلمة المرور",
          passwordPlaceholder: "أدخل كلمة المرور",
          nameLabel: "الاسم الكامل",
          namePlaceholder: "كيف نرحب بك؟",
          loginCta: "دخول",
          registerCta: "إنشاء حساب"
        },
        dashboard: {
          title: "مركز تحكم MY1",
          subtitle: "أدر أفكار الذكاء الاصطناعي، راقب الأوامر المفتوحة، وأشرف على ربط Binance.",
          welcome: "مرحبًا",
          logout: "تسجيل الخروج"
        },
        api: {
          title: "ربط مفاتيح Binance",
          description: "أضف مفاتيح السبوت الخاصة بك لتفعيل المحرك. تبقى المفاتيح مشفرة ويمكنك إزالتها في أي وقت.",
          statusLabel: "الحالة:",
          connected: "متصل",
          disconnected: "غير متصل",
          keyLabel: "مفتاح API",
          secretLabel: "سر API",
          save: "حفظ المفاتيح",
          remove: "إلغاء الربط",
          helper: "استخدم مفاتيح تداول Spot بصلاحيات القراءة والتداول فقط."
        },
        manual: {
          title: "قاعدة يدوية",
          description: "اصنع إستراتيجية شراء عند الانخفاض بأهداف جني ربح مخصصة.",
          symbolLabel: "الزوج",
          symbolPlaceholder: "مثال: SOLUSDT",
          dipLabel: "نسبة الشراء عند الانخفاض %",
          dipPlaceholder: "2",
          tpLabel: "نسبة جني الربح %",
          tpPlaceholder: "2",
          budgetLabel: "ميزانية الصفقة (USDT)",
          budgetPlaceholder: "50",
          add: "إضافة القاعدة",
          sync: "مزامنة مع المحرك",
          tableTitle: "القواعد اليدوية",
          table: {
            rule: "القاعدة",
            targets: "الأهداف",
            budget: "الميزانية",
            status: "الحالة",
            actions: "إجراءات"
          }
        },
        ai: {
          title: "قاعدة بالذكاء الاصطناعي",
          description: "اطلب إستراتيجية تداول فورية مدعومة ببحث لحظي.",
          budgetLabel: "ميزانية الذكاء الاصطناعي (USDT)",
          modelLabel: "النموذج",
          generate: "توليد بالذكاء الاصطناعي",
          helper: "يقوم المساعد بالبحث في البيانات المباشرة قبل إرسال القاعدة.",
          tableTitle: "قواعد الذكاء الاصطناعي",
          table: {
            rule: "القاعدة",
            entry: "سعر الدخول",
            exit: "هدف الربح",
            budget: "الميزانية",
            status: "الحالة",
            actions: "إجراءات"
          }
        },
        orders: {
          title: "الأوامر المفتوحة",
          refresh: "تحديث",
          table: {
            symbol: "الزوج",
            side: "الاتجاه",
            price: "السعر",
            qty: "الكمية",
            type: "النوع",
            status: "الحالة",
            updated: "آخر تحديث"
          },
          empty: "لا توجد أوامر مفتوحة حاليًا."
        },
        completed: {
          title: "الصفقات المكتملة",
          subtitle: "أحدث دورات الشراء والبيع مع صافي الربح المحقق.",
          refresh: "تحديث",
          status: "مكتملة",
          closed: "أُغلقت",
          opened: "وقت الفتح",
          duration: "المدة",
          instant: "فوري",
          empty: "لا توجد صفقات مكتملة بعد.",
          table: {
            pair: "الزوج",
            quantity: "الكمية",
            avgBuy: "متوسط الشراء",
            avgSell: "متوسط البيع",
            profit: "الربح",
            cycle: "الجدول الزمني"
          },
          labels: {
            quantity: "الكمية",
            avgBuy: "متوسط الشراء",
            avgSell: "متوسط البيع",
            profit: "الربح",
            return: "العائد"
          }
        },
        manualRules: {
          buyOnDipLabel: "الشراء عند الانخفاض:",
          takeProfitLabel: "جني الربح:",
          empty: "لا توجد قواعد يدوية بعد."
        },
        aiRules: {
          summaryToggle: "عرض ملخص الذكاء الاصطناعي",
          empty: "لا توجد قواعد ذكاء اصطناعي بعد."
        },
        common: {
          delete: "حذف",
          confirmDelete: "حذف هذه القاعدة؟",
          enabled: "مفعل",
          disabled: "موقوف"
        },
        status: {
          loginSuccess: "تم تسجيل الدخول بنجاح.",
          registerSuccess: "تم إنشاء الحساب بنجاح.",
          keysSaved: "تم حفظ مفاتيح API.",
          keysRemoved: "تم إلغاء الربط.",
          manualAdded: "تمت إضافة القاعدة اليدوية.",
          manualSynced: "تمت مزامنة القواعد مع المحرك.",
          aiGenerated: "تم توليد قاعدة ذكاء اصطناعي بنجاح.",
          ordersRefreshed: "تم تحديث الأوامر المفتوحة.",
          completedRefreshed: "تم تحديث الصفقات المكتملة.",
          ruleActivated: "تم تفعيل القاعدة.",
          rulePaused: "تم إيقاف القاعدة.",
          ruleDeleted: "تم حذف القاعدة.",
          aiBudgetInvalid: "أدخل ميزانية صحيحة للذكاء الاصطناعي.",
          manualLocked: "القواعد اليدوية غير متاحة في باقتك الحالية.",
          aiLocked: "قواعد الذكاء الاصطناعي غير متاحة في باقتك الحالية.",
          manualLimit: "باقتك تسمح حتى {{count}} من القواعد اليدوية.",
          aiLimit: "باقتك تسمح حتى {{count}} من قواعد الذكاء الاصطناعي.",
          checkoutStarted: "جاري تحويلك لإتمام الدفع...",
          checkoutError: "تعذر بدء عملية الدفع، حاول مرة أخرى."
        },
        subscription: {
          title: "باقتك",
          statusActive: "مفعلة",
          statusExpired: "منتهية",
          statusPending: "بانتظار الدفع",
          statusNone: "لا توجد باقة مفعلة",
          noPlan: "لا توجد باقة مفعلة. اختر الباقة المناسبة لتفعيل الخصائص.",
          currentPlan: "الباقة الحالية: {{name}}",
          expires: "تنتهي في {{date}}",
          daysLeft: "متبقي {{count}} يومًا",
          daysLeftOne: "متبقي يوم واحد",
          manualFeature: "القواعد اليدوية: {{used}} / {{limit}} مفعلة",
          manualUnlimited: "القواعد اليدوية مفعلة",
          aiFeature: "قواعد الذكاء الاصطناعي: {{used}} / {{limit}} مفعلة",
          aiUnlimited: "قواعد الذكاء الاصطناعي مفعلة",
          manualDisabled: "القواعد اليدوية غير متاحة في باقتك الحالية.",
          aiDisabled: "قواعد الذكاء الاصطناعي غير متاحة في باقتك الحالية.",
          availablePlans: "الباقات المتاحة",
          chooseProvider: "اختر طريقة الدفع",
          payWithStripe: "الدفع بالبطاقة (Stripe)",
          payWithCryptomus: "الدفع بالعملات الرقمية (Cryptomus)",
          loginRequired: "سجل الدخول للاشتراك في باقة.",
          renewing: "جاري تأكيد عملية الدفع...",
          historyTitle: "سجل الدفعات",
          historyEmpty: "لا يوجد سجل دفعات بعد.",
          pendingNotice: "بانتظار تأكيد الدفع لباقـة {{name}}.",
          providerStripe: "سترايب",
          providerCryptomus: "كريبتومس",
          noPlans: "سيتم إتاحة الباقات قريبًا."
        },
        ruleErrors: {
          symbolNotWhitelisted: "رفضت باينانس تنفيذ {{symbol}} لأن الزوج غير مفعّل لمفتاح الـ API الخاص بك. فعّل الزوج من إعدادات قيود مفاتيح باينانس ثم أعد المحاولة."
        }
      }
    };

    const state = {
      language: localStorage.getItem('mybot_language') || 'en',
      token: localStorage.getItem('mybot_token') || '',
      user: null,
      rules: [],
      plans: [],
      providers: { stripe: false, cryptomus: false },
      entitlements: null,
      ordersTimer: null,
      statusTimer: null,
      hasKeys: false,
      isOrdersLoading: false,
      completedTrades: [],
      completedTradesErrors: [],
      isCompletedTradesLoading: false,
      lastRuleErrorsDigest: ''
    };

    const generateId = () => {
      if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      return `rule_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    };

    const landing = document.getElementById('landing');
    const authSection = document.getElementById('authSection');
    const dashboard = document.getElementById('dashboard');
    const statusEl = document.getElementById('status');
    const loginForm = document.getElementById('loginForm');
    const registerForm = document.getElementById('registerForm');
    const authTabs = document.querySelectorAll('[data-auth-tab]');
    const welcomeName = document.getElementById('welcomeName');
    const logoutBtn = document.getElementById('logoutBtn');
    const apiKeysStatus = document.getElementById('apiKeysStatus');
    const apiKeysForm = document.getElementById('apiKeysForm');
    const removeKeysBtn = document.getElementById('removeKeys');
    const manualForm = document.getElementById('manualForm');
    const syncRulesBtn = document.getElementById('syncRules');
    const aiForm = document.getElementById('aiForm');
    const aiGenerateBtn = document.getElementById('aiGenerate');
    const aiBudgetInput = document.getElementById('aiBudget');
    const aiModelInput = document.getElementById('aiModel');
    const manualTableBody = document.querySelector('#manualRulesTable tbody');
    const aiTableBody = document.querySelector('#aiRulesTable tbody');
    const ordersTableBody = document.querySelector('#ordersTable tbody');
    const completedTradesTable = document.getElementById('completedTradesTable');
    const completedTradesList = document.getElementById('completedTradesList');
    const completedTradesNotice = document.getElementById('completedTradesNotice');
    const manualCountEl = document.getElementById('manualCount');
    const aiCountEl = document.getElementById('aiCount');
    const refreshOrdersBtn = document.getElementById('refreshOrders');
    const refreshCompletedBtn = document.getElementById('refreshCompletedTrades');
    const languageToggle = document.getElementById('languageToggle');
    const pricingGrid = document.getElementById('pricingGrid');
    const dashboardPlansGrid = document.getElementById('dashboardPlans');
    const subscriptionStatus = document.getElementById('subscriptionStatus');
    const subscriptionSummary = document.getElementById('subscriptionSummary');
    const subscriptionFeaturesEl = document.getElementById('subscriptionFeatures');
    const subscriptionWarning = document.getElementById('subscriptionWarning');
    const subscriptionActions = document.getElementById('subscriptionActions');
    const subscriptionHistory = document.getElementById('subscriptionHistory');
    const manualRestriction = document.getElementById('manualRestriction');
    const aiRestriction = document.getElementById('aiRestriction');
    const subscriptionCard = document.getElementById('subscriptionCard');

    function resolveTranslation(lang, key) {
      const fallback = translations.en;
      const parts = key.split('.');
      let target = translations[lang] || translations.en;
      let fallbackTarget = fallback;
      for (const part of parts) {
        target = target && target[part] !== undefined ? target[part] : undefined;
        fallbackTarget = fallbackTarget && fallbackTarget[part] !== undefined ? fallbackTarget[part] : undefined;
      }
      return target !== undefined ? target : fallbackTarget;
    }

    function translate(key, params) {
      let value = resolveTranslation(state.language, key);
      if (typeof value !== 'string') return key;
      if (params) {
        value = value.replace(/\{\{(.*?)\}\}/g, (_, token) => {
          const trimmed = token.trim();
          return params[trimmed] !== undefined ? params[trimmed] : '';
        });
      }
      return value;
    }

    let currentOrdersCache = [];

    function applyTranslations() {
      const lang = state.language === 'ar' ? 'ar' : 'en';
      document.documentElement.lang = lang;
      document.documentElement.dir = lang === 'ar' ? 'rtl' : 'ltr';
      document.title = resolveTranslation(lang, 'meta.title');
      languageToggle.textContent = lang === 'ar' ? 'English' : 'عربي';

      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        const text = resolveTranslation(lang, key);
        if (typeof text === 'string') {
          el.textContent = text;
        }
      });

      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        const text = resolveTranslation(lang, key);
        if (typeof text === 'string') {
          el.setAttribute('placeholder', text);
        }
      });

      const statusText = state.hasKeys ? resolveTranslation(lang, 'api.connected') : resolveTranslation(lang, 'api.disconnected');
      apiKeysStatus.textContent = statusText;
      apiKeysStatus.className = `pill ${state.hasKeys ? 'success' : 'danger'}`;

      renderPricingCards();
      renderDashboardPlans();
      renderSubscription();
      renderTables();
      renderOrders(currentOrdersCache);
      renderCompletedTrades(state.completedTrades, state.completedTradesErrors);
    }

    function setStatus(message, type = 'info') {
      if (!statusEl) return;
      statusEl.textContent = message || '';
      statusEl.className = `status ${message ? type : ''}`.trim();
      clearTimeout(state.statusTimer);
      if (message) {
        state.statusTimer = setTimeout(() => {
          statusEl.textContent = '';
          statusEl.className = 'status';
        }, 6000);
      }
    }

    function setToken(token) {
      state.token = token || '';
      if (state.token) {
        localStorage.setItem('mybot_token', state.token);
      } else {
        localStorage.removeItem('mybot_token');
      }
    }

    function setLanguage(lang) {
      state.language = lang === 'ar' ? 'ar' : 'en';
      localStorage.setItem('mybot_language', state.language);
      applyTranslations();
    }

    function showLanding() {
      landing.classList.remove('hidden');
      authSection.classList.remove('hidden');
      dashboard.classList.add('hidden');
    }

    function showDashboard() {
      landing.classList.add('hidden');
      authSection.classList.add('hidden');
      dashboard.classList.remove('hidden');
    }

    async function api(url, options = {}) {
      const headers = options.headers ? { ...options.headers } : {};
      if (state.token) headers['Authorization'] = `Bearer ${state.token}`;
      const opts = {
        ...options,
        headers,
      };
      if (options.body && typeof options.body === 'object' && !(options.body instanceof FormData)) {
        headers['Content-Type'] = 'application/json';
        opts.body = JSON.stringify(options.body);
      }
      const res = await fetch(url, opts);
      if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data.error || res.statusText || 'Request failed');
      }
      return res.json().catch(() => ({}));
    }

    function extractRules(payload) {
      const list = [];
      if (Array.isArray(payload)) return payload;
      if (payload && Array.isArray(payload.rules)) return payload.rules;
      if (payload && Array.isArray(payload.data)) return payload.data;
      return list;
    }

    async function loadPlans() {
      try {
        const data = await api('/api/plans');
        state.plans = Array.isArray(data?.plans) ? data.plans : [];
        state.providers = {
          stripe: Boolean(data?.providers?.stripe),
          cryptomus: Boolean(data?.providers?.cryptomus)
        };
        renderPricingCards();
        renderDashboardPlans();
      } catch (err) {
        console.error('plan load error', err);
        state.plans = Array.isArray(state.plans) ? state.plans : [];
      }
    }

    function renderTables() {
      renderManualRules();
      renderAiRules();
      announceRuleErrors();
      applyEntitlementsUI();
    }

    function escapeHtml(str) {
      return String(str || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }

    function formatNumber(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '-';
      const abs = Math.abs(num);
      const opts = { maximumFractionDigits: 8 };
      if (abs >= 1000) opts.maximumFractionDigits = 2;
      else if (abs >= 100) opts.maximumFractionDigits = 2;
      else if (abs >= 1) opts.maximumFractionDigits = 4;
      return num.toLocaleString(undefined, opts);
    }

    function formatCurrency(v) {
      const num = Number(v);
      if (!Number.isFinite(num)) return '-';
      return `${formatNumber(num)} USDT`;
    }

    function formatUsageCount(active, limit) {
      const used = Number(active) || 0;
      const cap = Number(limit);
      if (Number.isFinite(cap) && cap >= 0) {
        return `${used}/${cap}`;
      }
      return `${used}/0`;
    }

    function formatPercent(v) {
      const num = Number(v);
      if (!Number.isFinite(num)) return '-';
      return `${num.toFixed(2)}%`;
    }

    function formatDate(ms) {
      if (!ms) return '-';
      const d = new Date(Number(ms));
      if (Number.isNaN(d.getTime())) return '-';
      return d.toLocaleString(state.language === 'ar' ? 'ar-EG' : undefined);
    }

    function formatUSD(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '$0';
      const opts = num % 1 ? { minimumFractionDigits: 2, maximumFractionDigits: 2 } : { minimumFractionDigits: 0, maximumFractionDigits: 0 };
      return `$${Math.abs(num).toLocaleString(undefined, opts)}`;
    }

    function formatIsoDate(value) {
      if (!value) return '-';
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return '-';
      return date.toLocaleDateString(state.language === 'ar' ? 'ar-EG' : undefined, { year: 'numeric', month: 'short', day: 'numeric' });
    }

    function formatAsset(amount, asset) {
      const value = formatNumber(amount);
      if (value === '-') return '-';
      return asset ? `${value} ${asset}` : value;
    }

    function formatSignedCurrency(value, asset) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '-';
      const abs = formatNumber(Math.abs(num));
      const sign = num > 0 ? '+' : num < 0 ? '-' : '';
      return `${sign}${abs}${asset ? ` ${asset}` : ''}`.trim();
    }

    function formatSignedPercent(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '-';
      const abs = Math.abs(num).toFixed(2);
      const sign = num > 0 ? '+' : num < 0 ? '-' : '';
      return `${sign}${abs}%`;
    }

    function formatDuration(ms) {
      const num = Number(ms);
      if (!Number.isFinite(num) || num <= 0) {
        return translate('completed.instant');
      }
      const totalSeconds = Math.floor(num / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const labels = state.language === 'ar'
        ? { day: 'ي', hour: 'س', minute: 'د', second: 'ث' }
        : { day: 'd', hour: 'h', minute: 'm', second: 's' };
      const parts = [];
      if (days) parts.push(`${days}${labels.day}`);
      if (hours) parts.push(`${hours}${labels.hour}`);
      if (minutes) parts.push(`${minutes}${labels.minute}`);
      if (!parts.length && seconds) parts.push(`${seconds}${labels.second}`);
      return parts.length ? parts.slice(0, 2).join(' ') : translate('completed.instant');
    }

    function resolveRuleError(rule) {
      if (!rule) return '';
      if (rule.lastErrorCode === 'symbol_not_whitelisted') {
        return translate('ruleErrors.symbolNotWhitelisted', { symbol: rule.symbol || '' });
      }
      if (typeof rule.lastError === 'string' && rule.lastError.trim()) {
        return rule.lastError.trim();
      }
      return '';
    }

    function announceRuleErrors() {
      const issues = [];
      for (const rule of state.rules || []) {
        const message = resolveRuleError(rule);
        if (message) {
          issues.push({ id: rule.id, message, at: Number(rule.lastErrorAt) || 0 });
        }
      }
      const digest = issues.map(issue => `${issue.id}:${issue.message}:${issue.at}`).join('|');
      if (issues.length && digest !== state.lastRuleErrorsDigest) {
        const focus = issues.reduce((acc, item) => {
          if (!acc || item.at > acc.at) return item;
          return acc;
        }, issues[0]);
        setStatus(focus.message, 'error');
      }
      state.lastRuleErrorsDigest = digest;
    }

    function renderManualRules() {
      const manualRules = state.rules.filter(r => (r.type || '').toLowerCase() === 'manual');
      const ent = state.entitlements || {};
      const manualLimit = Number(ent?.manualLimit);
      const manualEnabled = Boolean(ent && ent.manualEnabled);
      const activeManual = state.rules.filter(r => (r.type || '').toLowerCase() === 'manual' && r.enabled).length;
      manualTableBody.innerHTML = '';
      if (!manualRules.length) {
        const tr = document.createElement('tr');
        tr.className = 'empty-row';
        tr.innerHTML = `<td colspan="5">${escapeHtml(translate('manualRules.empty'))}</td>`;
        manualTableBody.appendChild(tr);
        return;
      }
      for (const rule of manualRules) {
        const tr = document.createElement('tr');
        if (!rule.enabled) tr.classList.add('is-paused');
        tr.dataset.id = rule.id;
        const capReached = Number.isFinite(manualLimit) && manualLimit > 0 && activeManual >= manualLimit;
        const toggleDisabled = !manualEnabled || (!rule.enabled && capReached);
        const manualError = resolveRuleError(rule);
        const manualErrorHtml = manualError ? `<div class="rule-error">${escapeHtml(manualError)}</div>` : '';
        tr.innerHTML = `
          <td data-label="${escapeHtml(translate('manual.table.rule'))}">
            <div class="symbol">${escapeHtml(rule.symbol)}</div>
            ${manualErrorHtml}
          </td>
          <td data-label="${escapeHtml(translate('manual.table.targets'))}">
            <div>${escapeHtml(translate('manualRules.buyOnDipLabel'))} <strong>${formatPercent(rule.dipPct)}</strong></div>
            <div class="muted small">${escapeHtml(translate('manualRules.takeProfitLabel'))} ${formatPercent(rule.tpPct)}</div>
          </td>
          <td data-label="${escapeHtml(translate('manual.table.budget'))}">${formatCurrency(rule.budgetUSDT)}</td>
          <td data-label="${escapeHtml(translate('manual.table.status'))}">
            <label class="switch">
              <input type="checkbox" data-action="toggle" data-id="${rule.id}" ${rule.enabled ? 'checked' : ''} ${toggleDisabled ? 'disabled' : ''}>
              <span class="slider"></span>
            </label>
          </td>
          <td data-label="${escapeHtml(translate('manual.table.actions'))}">
            <button class="btn-text danger" data-action="delete" data-id="${rule.id}">${escapeHtml(translate('common.delete'))}</button>
          </td>
        `;
        manualTableBody.appendChild(tr);
      }
    }

    function renderAiRules() {
      const aiRules = state.rules.filter(r => (r.type || '').toLowerCase() === 'ai');
      const ent = state.entitlements || {};
      const aiLimit = Number(ent?.aiLimit);
      const aiEnabled = Boolean(ent && ent.aiEnabled);
      const activeAi = state.rules.filter(r => (r.type || '').toLowerCase() === 'ai' && r.enabled).length;
      aiTableBody.innerHTML = '';
      if (!aiRules.length) {
        const tr = document.createElement('tr');
        tr.className = 'empty-row';
        tr.innerHTML = `<td colspan="6">${escapeHtml(translate('aiRules.empty'))}</td>`;
        aiTableBody.appendChild(tr);
        return;
      }
      for (const rule of aiRules) {
        const tr = document.createElement('tr');
        if (!rule.enabled) tr.classList.add('is-paused');
        tr.dataset.id = rule.id;
        const aiError = resolveRuleError(rule);
        const aiErrorHtml = aiError ? `<div class="rule-error">${escapeHtml(aiError)}</div>` : '';
        const capReached = Number.isFinite(aiLimit) && aiLimit > 0 && activeAi >= aiLimit;
        const toggleDisabled = !aiEnabled || (!rule.enabled && capReached);
        tr.innerHTML = `
          <td data-label="${escapeHtml(translate('ai.table.rule'))}">
            <div class="symbol">${escapeHtml(rule.symbol)}</div>
            ${aiErrorHtml}
            <details class="ai-details">
              <summary>${escapeHtml(translate('aiRules.summaryToggle'))}</summary>
              <div class="ai-summary">${escapeHtml(rule.aiSummary || '')}</div>
            </details>
          </td>
          <td data-label="${escapeHtml(translate('ai.table.entry'))}">${formatNumber(rule.entryPrice)}</td>
          <td data-label="${escapeHtml(translate('ai.table.exit'))}">${formatNumber(rule.exitPrice)}</td>
          <td data-label="${escapeHtml(translate('ai.table.budget'))}">${formatCurrency(rule.budgetUSDT)}</td>
          <td data-label="${escapeHtml(translate('ai.table.status'))}">
            <label class="switch">
              <input type="checkbox" data-action="toggle" data-id="${rule.id}" ${rule.enabled ? 'checked' : ''} ${toggleDisabled ? 'disabled' : ''}>
              <span class="slider"></span>
            </label>
          </td>
          <td data-label="${escapeHtml(translate('ai.table.actions'))}">
            <button class="btn-text danger" data-action="delete" data-id="${rule.id}">${escapeHtml(translate('common.delete'))}</button>
          </td>
        `;
        aiTableBody.appendChild(tr);
      }
    }

    function renderOrders(rows) {
      currentOrdersCache = Array.isArray(rows) ? rows : [];
      ordersTableBody.innerHTML = '';
      if (!currentOrdersCache.length) {
        const tr = document.createElement('tr');
        tr.className = 'empty-row';
        tr.innerHTML = `<td colspan="7">${escapeHtml(translate('orders.empty'))}</td>`;
        ordersTableBody.appendChild(tr);
        return;
      }
      for (const item of currentOrdersCache) {
        if (item.error) {
          const tr = document.createElement('tr');
          tr.className = 'empty-row';
          tr.innerHTML = `<td colspan="7">${escapeHtml(item.symbol)}: ${escapeHtml(item.error)}</td>`;
          ordersTableBody.appendChild(tr);
          continue;
        }
        for (const order of item.orders || []) {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td data-label="${escapeHtml(translate('orders.table.symbol'))}">${escapeHtml(order.symbol)}</td>
            <td data-label="${escapeHtml(translate('orders.table.side'))}"><span class="pill ${order.side === 'BUY' ? 'success' : 'danger'}">${order.side}</span></td>
            <td data-label="${escapeHtml(translate('orders.table.price'))}">${formatNumber(order.price)}</td>
            <td data-label="${escapeHtml(translate('orders.table.qty'))}">${formatNumber(order.origQty)}</td>
            <td data-label="${escapeHtml(translate('orders.table.type'))}">${escapeHtml(order.type)}</td>
            <td data-label="${escapeHtml(translate('orders.table.status'))}">${escapeHtml(order.status)}</td>
            <td data-label="${escapeHtml(translate('orders.table.updated'))}">${formatDate(order.updateTime || order.time)}</td>
          `;
          ordersTableBody.appendChild(tr);
        }
      }
    }

    function renderCompletedTrades(rows, errors = []) {
      state.completedTrades = Array.isArray(rows) ? rows : [];
      state.completedTradesErrors = Array.isArray(errors) ? errors : [];

      if (completedTradesNotice) {
        if (state.completedTradesErrors.length) {
          completedTradesNotice.textContent = state.completedTradesErrors.join(' • ');
          completedTradesNotice.classList.add('visible');
        } else {
          completedTradesNotice.textContent = '';
          completedTradesNotice.classList.remove('visible');
        }
      }

      if (!completedTradesList) return;
      completedTradesList.innerHTML = '';

      const columnCount = completedTradesTable ? completedTradesTable.querySelectorAll('thead th').length : 0;

      if (!state.completedTrades.length) {
        const tr = document.createElement('tr');
        tr.className = 'empty-row';
        const td = document.createElement('td');
        td.colSpan = columnCount || 6;
        td.textContent = translate('completed.empty');
        tr.appendChild(td);
        completedTradesList.appendChild(tr);
        return;
      }

      const pairLabel = translate('completed.table.pair');
      const quantityLabel = translate('completed.table.quantity');
      const avgBuyLabel = translate('completed.table.avgBuy');
      const avgSellLabel = translate('completed.table.avgSell');
      const profitLabel = translate('completed.table.profit');
      const cycleLabel = translate('completed.table.cycle');
      const statusLabel = translate('completed.status');
      const openedLabel = translate('completed.opened');
      const closedLabel = translate('completed.closed');
      const durationLabel = translate('completed.duration');
      const returnLabel = translate('completed.labels.return');

      for (const trade of state.completedTrades) {
        if (!trade || typeof trade !== 'object') continue;

        const quantity = formatAsset(trade.quantity, trade.baseAsset);
        const buyPrice = formatAsset(trade.buyPrice, trade.quoteAsset);
        const sellPrice = formatAsset(trade.sellPrice, trade.quoteAsset);
        const profitValue = formatSignedCurrency(trade.profit, trade.quoteAsset);
        const profitPercent = formatSignedPercent(trade.profitPct);
        const profitClass = trade.profit > 0 ? 'positive' : trade.profit < 0 ? 'negative' : 'neutral';
        const openedAt = formatDate(trade.openedAt);
        const closedAt = formatDate(trade.closedAt);
        const duration = formatDuration(trade.durationMs);
        const pairMeta = [trade.baseAsset, trade.quoteAsset].filter(Boolean).join(' / ');
        const returnText = profitPercent === '-' ? '' : `${returnLabel} · ${profitPercent}`;

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td data-label="${escapeHtml(pairLabel)}">
            <div class="pair">
              <span class="pair-symbol">${escapeHtml(trade.symbol || '')}</span>
              ${pairMeta ? `<span class="pair-base">${escapeHtml(pairMeta)}</span>` : ''}
              <span class="status-pill">${escapeHtml(statusLabel)}</span>
            </div>
          </td>
          <td data-label="${escapeHtml(quantityLabel)}">
            <span class="metric-value">${escapeHtml(quantity)}</span>
          </td>
          <td data-label="${escapeHtml(avgBuyLabel)}">
            <span class="metric-value">${escapeHtml(buyPrice)}</span>
          </td>
          <td data-label="${escapeHtml(avgSellLabel)}">
            <span class="metric-value">${escapeHtml(sellPrice)}</span>
          </td>
          <td data-label="${escapeHtml(profitLabel)}">
            <span class="profit-amount ${profitClass}">${escapeHtml(profitValue)}</span>
            ${returnText ? `<span class="profit-return">${escapeHtml(returnText)}</span>` : ''}
          </td>
          <td data-label="${escapeHtml(cycleLabel)}">
            <div class="cycle">
              <span><strong>${escapeHtml(openedLabel)}:</strong> ${escapeHtml(openedAt)}</span>
              <span><strong>${escapeHtml(closedLabel)}:</strong> ${escapeHtml(closedAt)}</span>
              <span><strong>${escapeHtml(durationLabel)}:</strong> ${escapeHtml(duration)}</span>
            </div>
          </td>
        `;
        completedTradesList.appendChild(tr);
      }
    }

    function updateEntitlementsFromResponse(payload) {
      if (!payload) return;
      if (payload.subscription) {
        updateEntitlements(payload.subscription);
        return;
      }
      if (payload.entitlements) {
        updateEntitlements(payload.entitlements);
      }
    }

    function updateEntitlements(entitlements) {
      if (entitlements && typeof entitlements === 'object') {
        state.entitlements = entitlements;
      } else {
        state.entitlements = null;
      }
      renderSubscription();
      renderDashboardPlans();
      renderPricingCards();
      applyEntitlementsUI();
    }

    function applyEntitlementsUI() {
      const ent = state.entitlements || {};
      const hasPlan = Boolean(ent && ent.plan);
      const manualEnabled = Boolean(state.token && ent && ent.manualEnabled);
      const aiEnabled = Boolean(state.token && ent && ent.aiEnabled);
      const manualLimit = Number(ent?.manualLimit);
      const aiLimit = Number(ent?.aiLimit);
      const activeManual = state.rules.filter(r => (r.type || '').toLowerCase() === 'manual' && r.enabled).length;
      const activeAi = state.rules.filter(r => (r.type || '').toLowerCase() === 'ai' && r.enabled).length;
      const manualCapReached = manualEnabled && Number.isFinite(manualLimit) && manualLimit >= 0 && activeManual >= manualLimit;
      const aiCapReached = aiEnabled && Number.isFinite(aiLimit) && aiLimit >= 0 && activeAi >= aiLimit;

      if (manualCountEl) {
        manualCountEl.textContent = formatUsageCount(activeManual, manualLimit);
      }
      if (aiCountEl) {
        aiCountEl.textContent = formatUsageCount(activeAi, aiLimit);
      }

      if (manualForm) {
        const inputs = manualForm.querySelectorAll('input');
        inputs.forEach(input => {
          input.disabled = !manualEnabled;
        });
        const submit = manualForm.querySelector('button[type="submit"]');
        if (submit) {
          submit.disabled = !manualEnabled || manualCapReached;
        }
      }

      if (manualRestriction) {
        manualRestriction.classList.remove('visible', 'info');
        manualRestriction.textContent = '';
        let message = '';
        let info = false;
        if (!state.token) {
          message = translate('subscription.loginRequired');
        } else if (!hasPlan) {
          message = ent && ent.pending && ent.pending.plan
            ? translate('subscription.renewing')
            : translate('subscription.noPlan');
        } else if (!manualEnabled) {
          message = translate('status.manualLocked');
        } else if (manualCapReached && Number.isFinite(manualLimit) && manualLimit >= 0) {
          message = translate('status.manualLimit', { count: manualLimit });
          info = true;
        }
        if (message) {
          manualRestriction.textContent = message;
          manualRestriction.classList.add('visible');
          if (info) manualRestriction.classList.add('info');
        }
      }

      if (aiBudgetInput) {
        aiBudgetInput.disabled = !aiEnabled;
      }
      if (aiModelInput) {
        aiModelInput.disabled = true;
      }
      if (aiGenerateBtn) {
        const loading = aiGenerateBtn.dataset.loading === 'true';
        aiGenerateBtn.disabled = loading || !aiEnabled || aiCapReached;
      }

      if (aiRestriction) {
        aiRestriction.classList.remove('visible', 'info');
        aiRestriction.textContent = '';
        let message = '';
        let info = false;
        if (!state.token) {
          message = translate('subscription.loginRequired');
        } else if (!hasPlan) {
          message = ent && ent.pending && ent.pending.plan
            ? translate('subscription.renewing')
            : translate('subscription.noPlan');
        } else if (!aiEnabled) {
          message = translate('status.aiLocked');
        } else if (aiCapReached && Number.isFinite(aiLimit) && aiLimit >= 0) {
          message = translate('status.aiLimit', { count: aiLimit });
          info = true;
        }
        if (message) {
          aiRestriction.textContent = message;
          aiRestriction.classList.add('visible');
          if (info) aiRestriction.classList.add('info');
        }
      }
    }

    function renderPlanGrid(container, context) {
      if (!container) return;
      container.innerHTML = '';
      const plans = Array.isArray(state.plans) ? state.plans : [];
      if (!plans.length) {
        const empty = document.createElement('p');
        empty.className = 'muted';
        empty.textContent = translate('subscription.noPlans');
        container.appendChild(empty);
        return;
      }
      const ent = state.entitlements || {};
      const currentPlanId = ent.plan ? Number(ent.plan.id) : null;
      const pendingPlanId = ent && ent.pending && ent.pending.plan ? Number(ent.pending.plan.id) : null;
      const availableProviders = state.providers || {};
      for (const plan of plans) {
        const card = document.createElement('article');
        card.className = 'plan-card';
        const isCurrent = currentPlanId !== null && Number(plan.id) === currentPlanId;
        const isPending = pendingPlanId !== null && Number(plan.id) === pendingPlanId;
        if (isCurrent) card.classList.add('current');
        if (isPending) card.classList.add('pending');
        const manualLimit = Number(plan.manualLimit);
        const aiLimit = Number(plan.aiLimit);
        const manualText = plan.manualEnabled
          ? (Number.isFinite(manualLimit) && manualLimit > 0
              ? translate('pricing.manualFeature', { count: manualLimit })
              : translate('subscription.manualUnlimited'))
          : translate('subscription.manualDisabled');
        const aiText = plan.aiEnabled
          ? (Number.isFinite(aiLimit) && aiLimit > 0
              ? translate('pricing.aiFeature', { count: aiLimit })
              : translate('subscription.aiUnlimited'))
          : translate('pricing.aiDisabled');
        const durationText = translate('pricing.duration', { days: plan.durationDays });
        const headerParts = [];
        const badges = [];
        const entStatus = (ent.status || '').toLowerCase();
        if (isCurrent && entStatus === 'active') {
          badges.push(`<span class="plan-badge">${escapeHtml(translate('subscription.statusActive'))}</span>`);
        }
        if (isPending) {
          badges.push(`<span class="plan-badge">${escapeHtml(translate('subscription.statusPending'))}</span>`);
        }
        if (badges.length) {
          headerParts.push(badges.join(''));
        }
        headerParts.push(`<h3>${escapeHtml(plan.name)}</h3>`);
        if (plan.description) {
          headerParts.push(`<p class="muted">${escapeHtml(plan.description)}</p>`);
        }
        card.innerHTML = `
          <div>
            ${headerParts.join('')}
            <div class="plan-price">${escapeHtml(formatUSD(plan.priceUSD))}<span>${escapeHtml(durationText)}</span></div>
          </div>
          <ul class="plan-feature-list">
            <li>${escapeHtml(manualText)}</li>
            <li>${escapeHtml(aiText)}</li>
            <li>${escapeHtml(durationText)}</li>
          </ul>
        `;
        const actions = document.createElement('div');
        actions.className = 'plan-actions';
        const providers = [];
        if (availableProviders.stripe) providers.push({ provider: 'stripe', label: translate('subscription.payWithStripe') });
        if (availableProviders.cryptomus) providers.push({ provider: 'cryptomus', label: translate('subscription.payWithCryptomus') });
        if (!state.token) {
          const note = document.createElement('p');
          note.className = 'provider-label';
          note.textContent = translate('subscription.loginRequired');
          actions.appendChild(note);
        } else if (isCurrent && entStatus === 'active' && !isPending) {
          const note = document.createElement('p');
          note.className = 'provider-label';
          note.textContent = translate('subscription.statusActive');
          actions.appendChild(note);
        } else if (isPending) {
          const note = document.createElement('p');
          note.className = 'provider-label';
          note.textContent = translate('subscription.statusPending');
          actions.appendChild(note);
        } else if (!providers.length) {
          const note = document.createElement('p');
          note.className = 'provider-label';
          note.textContent = translate('status.checkoutError');
          actions.appendChild(note);
        } else {
          for (const item of providers) {
            const btn = document.createElement('button');
            btn.className = item.provider === 'stripe' ? 'btn primary' : 'btn ghost';
            btn.type = 'button';
            btn.dataset.action = 'checkout';
            btn.dataset.planId = plan.id;
            btn.dataset.provider = item.provider;
            btn.textContent = item.label;
            actions.appendChild(btn);
          }
        }
        card.appendChild(actions);
        container.appendChild(card);
      }
    }

    function renderPricingCards() {
      renderPlanGrid(pricingGrid, 'landing');
    }

    function renderDashboardPlans() {
      renderPlanGrid(dashboardPlansGrid, 'dashboard');
    }

    function renderSubscription() {
      if (!subscriptionCard) return;
      const ent = state.entitlements || null;
      const pending = ent && ent.pending ? ent.pending : null;
      if (subscriptionActions) {
        subscriptionActions.innerHTML = '';
      }
      if (!ent || !ent.plan) {
        subscriptionStatus.textContent = ent && pending ? translate('subscription.statusPending') : translate('subscription.statusNone');
        subscriptionStatus.className = `status-pill${pending ? ' pending' : ' expired'}`;
        subscriptionSummary.innerHTML = `<p class="subscription-meta">${escapeHtml(translate('subscription.noPlan'))}</p>`;
        subscriptionFeaturesEl.innerHTML = '';
        subscriptionWarning.classList.remove('visible', 'info');
        subscriptionWarning.textContent = '';
        if (subscriptionActions) {
          const note = document.createElement('p');
          note.className = 'muted';
          note.textContent = translate(
            pending && pending.plan
              ? 'subscription.renewing'
              : (state.token ? 'subscription.noPlan' : 'subscription.loginRequired')
          );
          subscriptionActions.appendChild(note);
        }
      } else {
        let statusKey = ent.status || 'active';
        if (statusKey === 'pending' || (pending && (!ent.plan || Number(pending.id) !== Number(ent.plan.id)))) {
          statusKey = 'pending';
        }
        let statusClass = 'status-pill';
        if (statusKey === 'pending') statusClass += ' pending';
        else if (statusKey === 'expired') statusClass += ' expired';
        subscriptionStatus.textContent = translate(`subscription.status${statusKey.charAt(0).toUpperCase()}${statusKey.slice(1)}`);
        subscriptionStatus.className = statusClass;
        const summaryParts = [];
        summaryParts.push(`<strong>${escapeHtml(translate('subscription.currentPlan', { name: ent.plan.name }))}</strong>`);
        if (ent.expiresAt) {
          summaryParts.push(`<span class="subscription-meta">${escapeHtml(translate('subscription.expires', { date: formatIsoDate(ent.expiresAt) }))}</span>`);
        }
        if (Number.isFinite(Number(ent.remainingDays)) && Number(ent.remainingDays) >= 0) {
          const days = Number(ent.remainingDays);
          const key = days === 1 ? 'subscription.daysLeftOne' : 'subscription.daysLeft';
          summaryParts.push(`<span class="subscription-meta">${escapeHtml(translate(key, { count: days }))}</span>`);
        }
        subscriptionSummary.innerHTML = summaryParts.join(' ');
        const activeManual = state.rules.filter(r => (r.type || '').toLowerCase() === 'manual' && r.enabled).length;
        const activeAi = state.rules.filter(r => (r.type || '').toLowerCase() === 'ai' && r.enabled).length;
        const manualLimit = Number(ent.manualLimit);
        const aiLimit = Number(ent.aiLimit);
        const manualText = ent.manualEnabled !== false
          ? (Number.isFinite(manualLimit) && manualLimit > 0
              ? translate('subscription.manualFeature', { used: activeManual, limit: manualLimit })
              : translate('subscription.manualUnlimited'))
          : translate('subscription.manualDisabled');
        const aiText = ent.aiEnabled !== false
          ? (Number.isFinite(aiLimit) && aiLimit > 0
              ? translate('subscription.aiFeature', { used: activeAi, limit: aiLimit })
              : translate('subscription.aiUnlimited'))
          : translate('subscription.aiDisabled');
        subscriptionFeaturesEl.innerHTML = `
          <span class="feature${ent.manualEnabled !== false ? '' : ' disabled'}">${escapeHtml(manualText)}</span>
          <span class="feature${ent.aiEnabled !== false ? '' : ' disabled'}">${escapeHtml(aiText)}</span>
        `;
        if (pending && pending.plan) {
          subscriptionWarning.textContent = translate('subscription.pendingNotice', { name: pending.plan.name });
          subscriptionWarning.classList.add('visible', 'info');
        } else {
          subscriptionWarning.classList.remove('visible', 'info');
          subscriptionWarning.textContent = '';
        }
        if (subscriptionActions) {
          if (statusKey === 'pending' || (pending && pending.plan)) {
            const note = document.createElement('p');
            note.className = 'muted';
            note.textContent = translate('subscription.renewing');
            subscriptionActions.appendChild(note);
          }
        }
      }

      const history = state.entitlements && Array.isArray(state.entitlements.history) ? state.entitlements.history : [];
      subscriptionHistory.innerHTML = '';
      if (!history.length) {
        const item = document.createElement('li');
        item.textContent = translate('subscription.historyEmpty');
        subscriptionHistory.appendChild(item);
      } else {
        for (const entry of history) {
          const li = document.createElement('li');
          const statusKey = entry.status ? entry.status.toLowerCase() : '';
          const labelKey = statusKey === 'active'
            ? 'subscription.statusActive'
            : statusKey === 'pending'
              ? 'subscription.statusPending'
              : statusKey === 'expired'
                ? 'subscription.statusExpired'
                : 'subscription.statusNone';
          const label = document.createElement('span');
          label.className = 'label';
          label.textContent = `${entry.plan?.name || ''}`.trim();
          const meta = document.createElement('span');
          meta.className = 'meta';
          const date = entry.updatedAt || entry.startedAt || entry.createdAt || entry.expiresAt;
          meta.textContent = `${translate(labelKey)} · ${formatIsoDate(date)}`;
          li.appendChild(label);
          li.appendChild(meta);
          subscriptionHistory.appendChild(li);
        }
      }
    }

    async function startCheckout(planId, provider, trigger) {
      if (!planId || !provider) return;
      if (!state.token) {
        setStatus(translate('subscription.loginRequired'), 'error');
        return;
      }
      const pendingPlanId = state.entitlements?.pending?.plan?.id;
      if (pendingPlanId && Number(pendingPlanId) === Number(planId)) {
        const pendingName = state.entitlements?.pending?.plan?.name || '';
        if (pendingName) {
          setStatus(translate('subscription.pendingNotice', { name: pendingName }), 'info');
        } else {
          setStatus(translate('subscription.renewing'), 'info');
        }
        return;
      }
      if (trigger) {
        if (trigger.dataset.loading === 'true') return;
        trigger.dataset.loading = 'true';
        trigger.disabled = true;
      }
      try {
        setStatus(translate('status.checkoutStarted'), 'info');
        const response = await api('/api/billing/checkout', {
          method: 'POST',
          body: { planId: Number(planId), provider }
        });
        updateEntitlementsFromResponse(response);
        const url = response?.checkout?.url;
        if (url) {
          window.location.href = url;
          return;
        }
        setStatus(translate('status.checkoutError'), 'error');
      } catch (err) {
        console.error('checkout error', err);
        setStatus(err.message || translate('status.checkoutError'), 'error');
      } finally {
        if (trigger) {
          trigger.disabled = false;
          delete trigger.dataset.loading;
        }
      }
    }

    async function refreshRuleErrors() {
      try {
        const data = await api('/api/rules/errors');
        const list = Array.isArray(data?.errors) ? data.errors : [];
        const map = new Map(list.map(item => [item.id, item]));
        let changed = false;
        const nextRules = state.rules.map(rule => {
          const entry = map.get(rule.id);
          if (entry) {
            const message = typeof entry.message === 'string' ? entry.message.trim() : '';
            const code = entry.code || undefined;
            const createdAt = Number(entry.createdAt) || Date.now();
            const nextMessage = message || undefined;
            const nextCode = code || undefined;
            const nextAt = createdAt;
            if (rule.lastError !== nextMessage || rule.lastErrorCode !== nextCode || Number(rule.lastErrorAt || 0) !== nextAt) {
              changed = true;
              return { ...rule, lastError: nextMessage, lastErrorCode: nextCode, lastErrorAt: nextAt };
            }
            return rule;
          }
          if (rule.lastError || rule.lastErrorCode || rule.lastErrorAt) {
            changed = true;
            const next = { ...rule };
            delete next.lastError;
            delete next.lastErrorCode;
            delete next.lastErrorAt;
            return next;
          }
          return rule;
        });
        if (changed) {
          state.rules = nextRules;
          renderTables();
        }
      } catch (err) {
        console.error('rule errors refresh failed', err);
      }
    }

    async function handleLogin(event) {
      event.preventDefault();
      const payload = {
        email: document.getElementById('loginEmail').value,
        password: document.getElementById('loginPassword').value
      };
      try {
        const res = await fetch('/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) throw new Error(data.error || 'Login failed');
        setToken(data.token);
        state.user = data.user;
        await bootstrapDashboard();
        setStatus(translate('status.loginSuccess'), 'success');
      } catch (err) {
        console.error('login error', err);
        setStatus(err.message, 'error');
      }
    }

    async function handleRegister(event) {
      event.preventDefault();
      const payload = {
        name: document.getElementById('registerName').value,
        email: document.getElementById('registerEmail').value,
        password: document.getElementById('registerPassword').value
      };
      try {
        const res = await fetch('/api/auth/register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) throw new Error(data.error || 'Registration failed');
        setToken(data.token);
        state.user = data.user;
        await bootstrapDashboard();
        setStatus(translate('status.registerSuccess'), 'success');
      } catch (err) {
        console.error('register error', err);
        setStatus(err.message, 'error');
      }
    }

    async function bootstrapDashboard() {
      try {
        await fetchCurrentUser();
        showDashboard();
        await loadPlans();
        await loadRules();
        await loadOrders();
        await loadCompletedTrades(true);
        await refreshApiKeysStatus();
        if (state.ordersTimer) clearInterval(state.ordersTimer);
        state.ordersTimer = setInterval(() => loadOrders(true), 8000);
      } catch (err) {
        console.error('bootstrap error', err);
        setStatus(err.message, 'error');
      }
    }

    async function fetchCurrentUser() {
      const data = await api('/api/auth/me');
      state.user = data.user;
      state.hasKeys = Boolean(data.hasApiKeys);
      updateEntitlementsFromResponse(data);
      const greeting = state.user?.name ? `${translate('dashboard.welcome')} ${state.user.name}` : translate('dashboard.welcome');
      welcomeName.textContent = greeting;
      updateApiKeysStatus();
    }

    async function loadRules() {
      try {
        const data = await api('/api/rules');
        state.rules = extractRules(data);
        updateEntitlementsFromResponse(data);
        renderTables();
      } catch (err) {
        console.error('load rules error', err);
        state.rules = Array.isArray(state.rules) ? state.rules : [];
        renderTables();
        throw err;
      }
    }

    async function persistAll(rules, message) {
      const response = await api('/api/rules', { method: 'POST', body: rules });
      state.rules = extractRules(response);
      updateEntitlementsFromResponse(response);
      renderTables();
      if (message) setStatus(message.text, message.type || 'success');
    }

    async function loadOrders(silent) {
      if (state.isOrdersLoading) return;
      state.isOrdersLoading = true;
      try {
        const data = await api('/api/orders');
        renderOrders(Array.isArray(data) ? data : []);
        if (!silent) setStatus(translate('status.ordersRefreshed'), 'info');
      } catch (err) {
        renderOrders([]);
        setStatus(err.message, 'error');
      } finally {
        await refreshRuleErrors();
        state.isOrdersLoading = false;
      }
    }

    async function loadCompletedTrades(silent) {
      if (state.isCompletedTradesLoading) return;
      state.isCompletedTradesLoading = true;
      try {
        const data = await api('/api/trades/completed');
        const trades = Array.isArray(data?.trades) ? data.trades : [];
        const errors = Array.isArray(data?.errors) ? data.errors : [];
        renderCompletedTrades(trades, errors);
        if (!silent) setStatus(translate('status.completedRefreshed'), 'info');
      } catch (err) {
        console.error('completed trades error', err);
        renderCompletedTrades([], [err.message]);
        setStatus(err.message, 'error');
      } finally {
        state.isCompletedTradesLoading = false;
      }
    }

    async function refreshApiKeysStatus() {
      try {
        const data = await api('/api/users/api-keys');
        state.hasKeys = Boolean(data.hasKeys);
      } catch (err) {
        state.hasKeys = false;
        console.error('api key status error', err);
      }
      updateApiKeysStatus();
    }

    function updateApiKeysStatus() {
      if (!apiKeysStatus) return;
      const label = state.hasKeys ? 'api.connected' : 'api.disconnected';
      apiKeysStatus.textContent = translate(label);
      apiKeysStatus.className = `pill ${state.hasKeys ? 'success' : 'danger'}`;
    }

    async function submitApiKeys(event) {
      event.preventDefault();
      const payload = {
        apiKey: document.getElementById('apiKey').value,
        apiSecret: document.getElementById('apiSecret').value
      };
      try {
        await api('/api/users/api-keys', { method: 'POST', body: payload });
        state.hasKeys = true;
        updateApiKeysStatus();
        setStatus(translate('status.keysSaved'), 'success');
      } catch (err) {
        console.error('api key save error', err);
        setStatus(err.message, 'error');
      }
    }

    async function removeApiKeys() {
      try {
        await api('/api/users/api-keys', { method: 'DELETE' });
        state.hasKeys = false;
        updateApiKeysStatus();
        setStatus(translate('status.keysRemoved'), 'info');
      } catch (err) {
        console.error('remove keys error', err);
        setStatus(err.message, 'error');
      }
    }

    async function addManualRule(event) {
      event.preventDefault();
      const ent = state.entitlements || {};
      if (!ent || !ent.plan || ent.manualEnabled === false) {
        setStatus(translate('status.manualLocked'), 'error');
        return;
      }
      const manualLimit = Number(ent?.manualLimit);
      const activeManual = state.rules.filter(r => (r.type || '').toLowerCase() === 'manual' && r.enabled).length;
      if (Number.isFinite(manualLimit) && manualLimit > 0 && activeManual >= manualLimit) {
        setStatus(translate('status.manualLimit', { count: manualLimit }), 'error');
        return;
      }
      const rule = {
        id: generateId(),
        type: 'manual',
        symbol: document.getElementById('symbol').value.trim().toUpperCase(),
        dipPct: Number(document.getElementById('dip').value),
        tpPct: Number(document.getElementById('tp').value),
        budgetUSDT: Number(document.getElementById('budget').value),
        enabled: true,
        createdAt: Date.now()
      };
      const next = [...state.rules, rule];
      try {
        await persistAll(next, { text: translate('status.manualAdded'), type: 'success' });
        manualForm.reset();
      } catch (err) {
        setStatus(err.message, 'error');
      }
    }

    async function syncRules() {
      try {
        const response = await api('/api/rules/sync', { method: 'POST' });
        state.rules = extractRules(response);
        updateEntitlementsFromResponse(response);
        renderTables();
        setStatus(translate('status.manualSynced'), 'info');
      } catch (err) {
        setStatus(err.message, 'error');
      }
    }

    async function toggleRule(id, enabled) {
      const rule = state.rules.find(r => r.id === id);
      if (!rule) return;
      if (enabled) {
        const ent = state.entitlements || {};
        const type = (rule.type || '').toLowerCase();
        if (!ent || !ent.plan) {
          const messageKey = type === 'manual' ? 'status.manualLocked' : 'status.aiLocked';
          setStatus(translate(messageKey), 'error');
          renderTables();
          return;
        }
        if (type === 'manual') {
          if (ent.manualEnabled === false) {
            setStatus(translate('status.manualLocked'), 'error');
            renderTables();
            return;
          }
          const manualLimit = Number(ent?.manualLimit);
          if (Number.isFinite(manualLimit) && manualLimit > 0) {
            const activeManual = state.rules.filter(r => (r.type || '').toLowerCase() === 'manual' && r.enabled).length;
            const nextActive = rule.enabled ? activeManual : activeManual + 1;
            if (nextActive > manualLimit) {
              setStatus(translate('status.manualLimit', { count: manualLimit }), 'error');
              renderTables();
              return;
            }
          }
        } else if (type === 'ai') {
          if (ent.aiEnabled === false) {
            setStatus(translate('status.aiLocked'), 'error');
            renderTables();
            return;
          }
          const aiLimit = Number(ent?.aiLimit);
          if (Number.isFinite(aiLimit) && aiLimit > 0) {
            const activeAi = state.rules.filter(r => (r.type || '').toLowerCase() === 'ai' && r.enabled).length;
            const nextActive = rule.enabled ? activeAi : activeAi + 1;
            if (nextActive > aiLimit) {
              setStatus(translate('status.aiLimit', { count: aiLimit }), 'error');
              renderTables();
              return;
            }
          }
        }
      }
      const next = state.rules.map(r => r.id === id ? { ...r, enabled } : r);
      try {
        await persistAll(next, { text: translate(enabled ? 'status.ruleActivated' : 'status.rulePaused'), type: 'info' });
      } catch (err) {
        setStatus(err.message, 'error');
        renderTables();
      }
    }

    async function deleteRule(id) {
      if (!id) return;
      if (!confirm(translate('common.confirmDelete'))) return;
      try {
        const data = await api(`/api/rules/${id}`, { method: 'DELETE' });
        state.rules = extractRules(data);
        updateEntitlementsFromResponse(data);
        renderTables();
        setStatus(translate('status.ruleDeleted'), 'info');
      } catch (err) {
        setStatus(err.message, 'error');
      }
    }

    async function generateAiRule(event) {
      event.preventDefault();
      if (aiGenerateBtn.dataset.loading === 'true') return;
      const budget = Number(document.getElementById('aiBudget').value);
      if (!(budget > 0)) {
        setStatus(translate('status.aiBudgetInvalid'), 'error');
        return;
      }
      const ent = state.entitlements || {};
      if (!ent || !ent.plan || ent.aiEnabled === false) {
        setStatus(translate('status.aiLocked'), 'error');
        return;
      }
      const aiLimit = Number(ent?.aiLimit);
      const activeAi = state.rules.filter(r => (r.type || '').toLowerCase() === 'ai' && r.enabled).length;
      if (Number.isFinite(aiLimit) && aiLimit > 0 && activeAi >= aiLimit) {
        setStatus(translate('status.aiLimit', { count: aiLimit }), 'error');
        return;
      }
      aiGenerateBtn.dataset.loading = 'true';
      aiGenerateBtn.disabled = true;
      try {
        const data = await api('/api/ai-role', {
          method: 'POST',
          body: { budgetUSDT: budget, locale: state.language }
        });
        updateEntitlementsFromResponse(data);
        await loadRules();
        if (data && data.rule && data.rule.aiModel) {
          const modelInput = document.getElementById('aiModel');
          if (modelInput) modelInput.value = data.rule.aiModel;
        }
        setStatus(translate('status.aiGenerated'), 'success');
        await loadOrders(true);
      } catch (err) {
        console.error('ai error', err);
        setStatus(err.message, 'error');
      } finally {
        aiGenerateBtn.disabled = false;
        delete aiGenerateBtn.dataset.loading;
      }
    }

    function handleLogout() {
      setToken('');
      state.user = null;
      state.rules = [];
      state.hasKeys = false;
      state.lastRuleErrorsDigest = '';
      state.completedTrades = [];
      state.completedTradesErrors = [];
      state.isCompletedTradesLoading = false;
      if (state.ordersTimer) clearInterval(state.ordersTimer);
      updateEntitlements(null);
      renderTables();
      renderOrders([]);
      renderCompletedTrades([]);
      showLanding();
    }

    function initAuthTabs() {
      authTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          authTabs.forEach(btn => btn.classList.toggle('is-active', btn === tab));
          const target = tab.getAttribute('data-auth-tab');
          document.querySelectorAll('[data-auth-panel]').forEach(panel => {
            panel.classList.toggle('hidden', panel.getAttribute('data-auth-panel') !== target);
          });
        });
      });
    }

    document.body.addEventListener('change', event => {
      const target = event.target;
      if (target && target.dataset && target.dataset.action === 'toggle') {
        toggleRule(target.dataset.id, target.checked);
      }
    });

    document.body.addEventListener('click', event => {
      const checkoutBtn = event.target.closest('[data-action="checkout"]');
      if (checkoutBtn) {
        event.preventDefault();
        startCheckout(checkoutBtn.dataset.planId, checkoutBtn.dataset.provider, checkoutBtn);
        return;
      }
      const deleteBtn = event.target.closest('[data-action="delete"]');
      if (deleteBtn) {
        deleteRule(deleteBtn.dataset.id);
      }
    });

    document.querySelectorAll('[data-scroll-to-auth]').forEach(btn => {
      btn.addEventListener('click', event => {
        event.preventDefault();
        window.scrollTo({ top: authSection.offsetTop - 40, behavior: 'smooth' });
      });
    });

    loginForm.addEventListener('submit', handleLogin);
    registerForm.addEventListener('submit', handleRegister);
    logoutBtn.addEventListener('click', handleLogout);
    apiKeysForm.addEventListener('submit', submitApiKeys);
    removeKeysBtn.addEventListener('click', removeApiKeys);
    manualForm.addEventListener('submit', addManualRule);
    syncRulesBtn.addEventListener('click', syncRules);
    aiForm.addEventListener('submit', generateAiRule);
    refreshOrdersBtn.addEventListener('click', () => loadOrders());
    refreshCompletedBtn.addEventListener('click', () => loadCompletedTrades());
    languageToggle.addEventListener('click', () => {
      setLanguage(state.language === 'ar' ? 'en' : 'ar');
    });

    initAuthTabs();

    async function init() {
      applyTranslations();
      renderTables();
      renderOrders([]);
      renderCompletedTrades([]);
      await loadPlans();
      if (state.token) {
        try {
          await bootstrapDashboard();
        } catch (err) {
          console.error('init error', err);
          setStatus(err.message, 'error');
          handleLogout();
        }
      }
    }

    init();
  })();
  </script>
</body>
</html>
